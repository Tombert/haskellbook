\begin{foreword}

Haskell, as a language, has a bit of a loaded reputation.  

A lot of programmers assume that Haskell is that ``mathey language", and once they hear mention of functors, monoids, monads, and arrows, they end up with the conclusion that it is a a tool that might have some interesting ideas, but is too academic to be suitable for any kind of practical use. 

This is an easy viewpoint to have.  There is a steep, non-trivial learning curve to the minutia of functional programming, and Haskell is among the most dogmatic of the functional languages; to understand Haskell is to understand the basics of algebra, Category Theory, Type Theory, and Set Theory.  Consequently, a lot of people assume that people learn Haskell so that they can look smart. 

While this is certainly true (and is why I picked up the language initially), functional programming has started to become fairly popular in the last couple years, and many people have started to appreciate the benefits of concepts like immutability, a clear type system, and the mathematical safety that programming in a functional style provides. The rise in popularity in languages like Scala, Rust, and F\#, as well as the newer functional features being added to Java 8, C++, and C\# has shown us that there is a clear market for functional programming in the field of computer science. 

Learning Haskell is about more than just the language. Haskell has become the poster-child for the testing ground of the cutting edge features of computer science. New methods of parallelism, thread safety, parsing, and nearly every other new programming theory comes over to Haskell first. 

But what you get with Haskell isn't just access to functional features.  Indeed, if you wanted an excuse to play with functional programming, the barrier of entry to do so is much lower with JavaScript.  

What you get from Haskell is a purely devoted, unambiguous entry to a functional way of structuring your programs, with all the benefits and annoyances that come with that. You get all the frustration of having to avoid state, but also all the benefits of guarantees that your functions will work exactly the same after being run a trillion times. You get all the frustration of having to use recursion instead of loops, but all the benefit of knowing that you'll never be forced to deal with a \inlinecode{null} reference error. 

What you get with Haskell is something you do not get with many other languages: guarantees. Mathematics is one of the very few things in life that boasts in its proofs and correctness and by taking a purely mathematical approach allows you to reap all the benefits of all that scary topics that I mentioned before. 
And with those guarantees, you find that Haskell is a language \textit{especially} well-suited for production systems that need to \textit{keep working}.  

\rule{330pt}{1pt}

Upon learning Haskell, it's not uncommon for a person to re-evaluate and change their entire coding process to use a more functional style, or to start utilizing the functional features of their favorite language. 

Being forced to view things from a different, strange angle can be a godsend in how you approach problems; sometimes approaching certain problems from a functional perspective can greatly simplify the problem. Recursion is a useful, often-underutilized tool that becomes easier to understand once confronted with a world without loops. Optional types give compile-time checks to that completely infamous \inlinecode{null} reference exception. Higher-order functions give a level or modularity that is nearly impossible to replicate with traditional imperative coding styles. 



\end{foreword}

