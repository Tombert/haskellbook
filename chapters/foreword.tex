\begin{foreword}

Haskell, as a language, has a bit of a loaded reputation.  

A lot of programmers assume that Haskell is that ``mathey language", and once they hear mention of functors, monoids, monads, and arrows, they end up with the conclusion that it is a a tool that might have some interesting ideas, but is too academic to be suitable for any kind of practical use. 

This is an easy viewpoint to have.  There is a steep, non-trivial learning curve to the minutia of functional programming, and Haskell is among the most dogmatic of the functional languages; to understand Haskell is to understand the basics of algebra, Category Theory, Type Theory, and Set Theory.  Consequently, a lot of people assume that people learn Haskell so that they can look smart. 

While this is certainly true (and is why I picked up the language initially), functional programming has started to become fairly popular in the last couple years, and many people have started to appreciate the benefits of concepts like immutability, a clear type system, and the mathematical safety that programming in a functional style provides. The rise in popularity in languages like Scala, Rust, and F\#, as well as the newer functional features being added to Java 8, C++, and C\# has shown us that there is a clear market for functional programming in the field of computer science. 

So if these languages have all these great functional features, why should someone bother learning Haskell, instead of Scala or Java 8?  Don't these languages get all the benefits of Haskell with all the extra features of popularity? 

What you get with Haskell isn't just access to functional features.  Indeed, if you wanted an excuse to play with functional programming, the barrier of entry to do so is much lower with JavaScript.  

What you get from Haskell is a purely devoted, unambiguous entry to a functional way of structuring your programs, with all the benefits and annoyances that come with that. You get all the frustration of having to avoid state, but also all the benefits of guarantees that your functions will work exactly the same after being run a trillion times. You get all the frustration of having to use recursion instead of loops, but all the benefit of knowing that you'll never be forced to deal with a \inlinecode{null} reference error. 

What you get with Haskell is something you do not get with many other languages: guarantees. Mathematics is one of the very few things in life that boasts in its proofs and correctness and by taking a purely mathematical approach allows you to reap all the benefits of all that scary topics that I mentioned before. 
And with those guarantees, you find that Haskell is a language \textit{especially} well-suited for production systems that need to \textit{keep working}. 


\end{foreword}

